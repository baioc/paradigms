(import (scheme base)
        (scheme read)
        (scheme write)
        (srfi 1)
        (srfi 27)
        (match))

(define (rule-pattern rule) (car rule))
(define (rule-responses rule) (cdr rule))

(define eliza-rules
  '((((?* ?x) hello (?* ?y))
     (How do you do. Please state your problem.))
    (((?* ?x) I want (?* ?y))
     (What would it mean if you got ?y)
     (Why do you want ?y)
     (Suppose you got ?y soon. Then what))
    (((?* ?x) if (?* ?y))
     (Do you really think it is likely that ?y)
     (Do you wish that ?y)
     (What do you think about ?y))
    (((?* ?x) no (?* ?y))
     (Why not?)
     (You are being a bit negative)
     (Are you saying that just to be negative?))
    (((?* ?x) I was (?* ?y))
     (Were you really ?)
     (Perhaps I already knew you were ?y)
     (Why do you tell me you were ?y now?))
    (((?* ?x) I feel (?* ?y))
     (Do you often feel ?y ?))
    (((?* ?x) I felt (?* ?y))
     (What other feelings do you have?))))

(define (eliza)
  (display "you: ")
  (let ((input (read)))
    (cond ((or (eof-object? input) (equal? input '(quit))  (eq? input 'q))
           (display "eliza: bye!\n"))
          (else
           (display "eliza: ")
           (print (eliza-eval input eliza-rules))
           (eliza)))))

(define (eliza-eval input rules)
  (any (lambda (rule)
         (let ((result (pattern-match (rule-pattern rule) input)))
           (and result
                (let ((responses (rule-responses rule)))
                  (substitute
                   (switch-viewpoint result)
                   (list-ref responses (random-integer (length responses))))))))
       rules))

(define (switch-viewpoint phrase)
  (substitute '((I . you) (you . I) (me . you) (am . are)) phrase))

(define (substitute subs original)
  (cond ((null? original) original)
        ((pair? original)
         (cons (substitute subs (car original))
               (substitute subs (cdr original))))
        (else
         (cond ((assoc original subs) => cdr)
               (else original)))))

(define (print reply)
  (define (display-flattened-list list)
    (for-each (lambda (elem)
                (cond ((list? elem) (display-flattened-list elem))
                      (else (display elem) (display " "))))
            list))
  (cond (reply => display-flattened-list)
        (else (display "I do not understand what you mean")))
  (newline))

(eliza)
